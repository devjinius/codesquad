# 객체지향 프로그래밍

## 객체란

현실세계의 추상적인 것들이 모두 객체이다. 예를들어 컵이라고 생각했을때 떠오르는 것이 모두 객체다.

그런데 컵은 손잡이가 있는 컵, 머그컵, 소주잔 등등 떠올리는 컵은 다양하다. 그 중 컵이라면 이런건 있어야지! 하고 정의하는 것이 클래스다. 클래스에는 속성과 행동이 있다. 그리고 그걸 하나하나 만들면 추상적인 객체다(인스턴스)

## OOP

이 객체(인스턴스)는 각각 다른 메모리에 들어간다. 따라서 객체 a가 죽는다고 b에 영향이 없다.

그런데 영향을 줘야하는 경우도 있다. 책과 현금의 연관관계는 없지만 내가 책을 사면 현금이 줄어든다.

이렇게 객체간의 연관성을 정리하는 것이 객체 지향 프로그래밍이다.

그 연관성을 어떻게하면 잘 정리할 수 있을까 하고 고민하면 그게 디자인(설계)다. 프로그램을 객체지향적으로 설계하는 것은 이 의존성을 어떤 방식으로 관리할 것인가를 정리하는 것이다.

대표적으로 좋은 OOP는 유지보수에 용이하며, 높은 응집도, 낮은 결합도를 가진다.

### 핵심 개념

OOP 핵심 개념은 아래와 같다.

- Class
- 캡슐화(Encapsulation)
- 상속(Inheritance)
- 다형성(polymorphism)
- 추상화(abstraction)

어느 문서에서는 `캡슐화, 상속, 다형성` 세가지라고도 얘기한다.

#### 추상화

DB에서 모델링의 개념과도 일맥상통하는 것 같다. 모델링은 리얼 월드에서 내가 관심있는 것만 뽑아서 재정의하는 것이다.

추상화도 이와 비슷하게 세상의 객체들 중 원하는 필요한 특성만 단순화하여 정의하는 것이라고 생각한다.

흔히 예를 드는 차에서 벤츠, BMW, 현대, 혼다 등등은 모두 `차`라는 추상화를 할 수 있다. 또한 소나타, 그랜저, 아반떼 등은 모두 `현대차`라는 추상화가 가능하다.

구체적인것에서 특성만 뽑아 상위 개념을 잡는 것이 추상화라고 생각한다.

구체화의 반대라고 생각하면 좀 더 쉽지 않을까

#### 캡슐화

클래스에는 속성과 행동이 있다. 캡슐화는 쉽게 말해서 속성을 직접 접근할 수 없고 행동(메서드)을 통해서 접근 가능하게 만드는 것이다.

또한 실제 구현 내용의 일부를 외부에 감추는 것을 말한다.

데이터를 직접 수정하지 못하게 하고 메서드를 통해 사용 가능하게 한다. 따라서 내부 구조가 바뀌더라도 이를 이용하는 메서드의 반환값이 바뀌지 않는 이상 다른 객체에게 영향을 주지 않는다. 즉 결합도를 낮춘다.

또 얻는 부수적인 효과로는 외부에서 필요하지 않는 내용은 굳이 공개하지 않을 수 있다는 점이다.

#### 상속

상속은 중복 제거에 큰 힘을 가진다. 글자그대로 속성과 행동을 상속 받는 것이다. 핸드폰 클래스의 특징을 아이폰이나 갤럭시가 가질 수 있는 것이 상속이다. 또한 아이폰 6, 7, 8, 10등등의 공통인 점은 아이폰 클래스에 만들어 이를 상속받게 할 수 있다.

그럼 중복이 제거됩니다. 로직이 바뀌거나 속성의 추가 삭제의 경우에도 한군데에서만 수정하면 되기 때문이다.

## SOLID

좋은 객체지향 디자인의 5원칙(SOLID)이다. 크롱이 말했듯 중요한 것은 이걸 달달 외우는 것이 아니다. 디자인 시 내가 어떤 철학을 가지고 해야 하는가? 라는 질문에 SOLID를 염두에 두고 실제 디자인을 하는 것이 더 중요하다.

### SRP

Single Responsibility Principle 단일 책임 원칙. 객체가 오직 하나의 책임을 가져야 한다는 원칙인데 이 말은 좀 모호하다고 생각한다. 의역하면 클래스를 수정할 경우 책임이 한가지이므로 클래스가 수정되는 이유도 한가지가 되어야 한다는 것이다.

즉 리팩토링 시 클래스의 변경이 일어날 때 그 클래스가 변경되어야 하는 이유는 단 한가지라는 의미다.

변경되는 이유가 하나, 즉 다시 원어로 돌아가 single responsibility의 원칙인 것이다.

### OCP

Open-Closed Principle 개방 폐쇄 원칙.

이건 명확하다. 객체가 확장되는 것은 open되어야하고 수정되는것은 closed 되어야 한다는 원칙이다. 즉 확장은 허용하고 스스로의 변경은 피하자는 것이다.

사람이 밥을 먹는건 똑같지만 아파서 밥을 제대로 못먹는다면 밥 먹는 메서드를 수정하면 안된다. 밥을 제대로 먹지 못하면서 밥을 먹는 새로운 메서드로 확장하는 것이 옳다.

### LSP

Liskov Substitution Principle 리스콥 치환 원리.

자식 클래스는 언제나 부모 클래스를 대체할 수 있다는 원리다. 이 말은 부모클래스가 들어가는 자리에 자식클래스가 들어가도 상관이 없어야 한다는 것이다.

자식 클래스는 항상 부모 클래스를 상속 받는다. 그렇다면 부모 클래스가 하는 역할을 자식 클래스가 완벽하게 소화해야 맞다.

제대로 클래스 계층을 디자인하고 구현했다면 이 원칙이 지켜지지 않는 것이 더 이상할 것이다.

자세한 사항은 [여기서 더 보자](https://vandbt.tistory.com/41)

### ISP

Interface Segregation Principle 인터페이스 분리 원칙.

자신이 사용하지 않는 메서드에 의존해서는 안된다는 원칙이다. 조금 개념이 모호한데 인터페이스를 생각하면 쉬워진다. 큰 덩어리의 클래스를 많은 인터페이스로 쪼개 클라이언트가 꼭 필요한 것만 사용하게 하자! 라는 것이다.

좀 더 구체적으로 말하자면 자신이 사용하는 메서드에는 영향을 받아서도 안되며 줘서도 안된다는 것이다.

예를들어 게임에서 충돌과 이펙트가 발생한다고 가정하자. 그럼 클라이언트는 이 충돌과 이펙트를 받아 인터페이스를 구현하는 메서드를 가지고 있을 것이다. 그런데 충돌 인터페이스 구현 메서드와 이펙트 인터페이스 구현 메서드는 서로 영향은 없지만 클라이언트 객체에 같이 들어있다. 서로 의존하지 않는데 클라이언트 클래스에 의존되어 버린다. 따라서 충돌과 이펙트 처리 인터페이스를 만들고 클라이언트는 이 둘을 상속하면 된다.

### DIP

Dependency Inversion Principle 의존성 역전 원칙

의존성의 inversion이 일어나서는 안된다는 원칙이다. 추상클래스는 구체적인 클래스에 영향을 받아서는 안된다는 것이다. 당연한거다. 상위 클래스가 하위 클래스에 의존해서는 안된다.

---

###참고자료

- [나무위키-객체 지향 프로그래밍/원칙](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)
- [위키- SOLID (객체 지향 설계)](<https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)>)
- [객체지향 디자인의 5원칙(SOLID 원칙)](https://wkdtjsgur100.github.io/solid-principle/)
